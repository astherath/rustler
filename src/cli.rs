extern crate ansi_term;
extern crate clap;
use super::common_structs::CommentType;
use ansi_term::Colour;
use clap::{App, Arg};
use std::{self, path::Path};

pub struct CommandLineArgs {
    pub input_path: String,
    pub context: usize,
    pub display_type: CommentType,
    pub output_filename: Option<String>,
    pub markdown_output_flag: bool,
}

impl CommandLineArgs {
    pub fn new() -> CommandLineArgs {
        CommandLineArgs::get_args()
    }

    fn get_args() -> CommandLineArgs {
        let matches = App::new("rustler")
                .version("1.0")
                .about("Rustles files for TODO and FIXME comments")
                // Required filename arg that eventually gets checked for existence
                .arg(
                    Arg::with_name("filename")
                    .help("Sets the input file to rustle")
                    .required_unless("directory")
                )
                // Can be used in place of a file so that an entire directory tree can be processed recursively
                .arg(
                    Arg::with_name("directory")
                    .help("Path for directory to rustle recursively")
                    .required(false)
                )
                // Sets context lines opt
                .arg(
                    Arg::with_name("context")
                    .help("Tells rustler how many files of surrounding context to return for special lines")
                    .required(true)
                )
                // Sets the wanted type of display returned
                .arg(
                    Arg::with_name("type")
                    .help("Selects what type of special lines get displayed [default: all]")
                    .required(false)
                    .possible_values(&["todo", "fixme", "note", "xxx", "all"])
                )
                // Handles setting the output filename (if one given)
                .arg(
                    Arg::with_name("out")
                    .help("If set, a Markdown version of the special lines will be written to this file")
                    .required(false)
                    .long("output-file")
                    .require_equals(true)
                    .takes_value(true)
                )
                .get_matches();

        let input_path = {
            if let Some(filename) = matches.value_of("filename") {
                filename.to_string()
            } else {
                matches.value_of("directory").unwrap().to_string()
            }
        };

        if !Path::new(&input_path).exists() {
            let usage = matches.usage.expect("Usage not generated by CLI app");
            let error_msg = make_error_msg("Input path not found!", &usage);
            let err = clap::Error::with_description(&error_msg, clap::ErrorKind::InvalidValue);
            err.exit();
        }

        // gets the type of the display wanted
        let display_type_arg = matches.value_of("type").unwrap_or("all").to_string();
        let display_type = CommentType::get_display_type(&display_type_arg);

        // sets output filename if one given
        let markdown_output_flag;
        let output_filename = {
            match matches.value_of("out") {
                Some(file_str) => {
                    markdown_output_flag = true;
                    Some(file_str.to_string())
                }
                None => {
                    markdown_output_flag = false;
                    None
                }
            }
        };

        // context needs to be unwrapped from the cli then atoi'd into a usize
        let context: usize = matches.value_of("context").unwrap_or("0").parse().unwrap();
        CommandLineArgs {
            input_path,
            context,
            display_type,
            output_filename,
            markdown_output_flag,
        }
    }
}

fn make_error_msg(message: &str, usage: &str) -> String {
    let red_error_str = Colour::Red.paint("ERROR".to_string()).to_string();
    let green_usage_str = Colour::White.paint(usage);

    let error_msg = format!("{}: {}\n{}", red_error_str, message, green_usage_str);
    error_msg
}
