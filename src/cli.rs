pub mod cli {
    extern crate ansi_term;
    extern crate clap;
    use ansi_term::Colour;
    use clap::{App, Arg};
    use std::{self, path::Path};

    pub struct CommandLineArgs {
        pub filename: String,
        pub context: usize,
    }

    fn make_error_msg(message: &str, usage: &str) -> String {
        let red_error_str = Colour::Red.paint("ERROR".to_string()).to_string();
        let green_usage_str = Colour::White.paint(usage);

        let error_msg = format!("{}: {}\n{}", red_error_str, message, green_usage_str);
        error_msg
    }

    impl CommandLineArgs {
        pub fn new() -> CommandLineArgs {
            CommandLineArgs::get_args()
        }

        fn get_args() -> CommandLineArgs {
            let matches = App::new("rustler")
                .version("1.0")
                .about("Rustles files for TODO and FIXME comments")
                .arg(
                    Arg::with_name("filename")
                    .help("Sets the input file to rustle")
                    .required(true)
                )
                .arg(
                    Arg::with_name("context")
                    .help("Tells rustler how many files of surrounding context to return for special lines")
                    .required(true)
                )
                .get_matches();

            // check that filename is valid and exists
            let filename = matches.value_of("filename").unwrap().to_string();

            let exists = Path::new(&filename).exists();
            if !exists {
                let usage = matches.usage.expect("Usage not generated by CLI app!");
                let error_msg = make_error_msg("File not found!", &usage);
                let err = clap::Error {
                    kind: clap::ErrorKind::InvalidValue,
                    message: error_msg,
                    info: None,
                };
                err.exit();
            }
            // context needs to be unwrapped from the cli then atoi'd into a usize
            let context: usize = matches.value_of("context").unwrap_or("0").parse().unwrap();
            CommandLineArgs { filename, context }
        }
    }
}
